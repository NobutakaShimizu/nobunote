{"0": {
    "doc": "ホーム",
    "title": "全体の大まかな流れ",
    "content": "マークダウンで書かれたページのファイルをローカルの環境でjekyllと呼ばれるソフトでコンパイルのような作業(htmlファイルやcssなどの生成)を行った後にリポジトリのmainブランチにプッシュするとGithub Actionを経由して更新が反映されるようになっています. 具体的には, Settings/PagesのBuild and deploymentの欄をGithub Actionsにした後にプッシュすれば良いです. ローカルでページプレビューするにはjekyllを使ってページビルドする必要があり, そのためにはrubyの環境構築が必要になります. そのための手順は以下に記しておきます (macを想定). ",
    "url": "/lecture_template/#%E5%85%A8%E4%BD%93%E3%81%AE%E5%A4%A7%E3%81%BE%E3%81%8B%E3%81%AA%E6%B5%81%E3%82%8C",
    
    "relUrl": "/#全体の大まかな流れ"
  },"1": {
    "doc": "ホーム",
    "title": "ローカルの環境設定方法",
    "content": " ",
    "url": "/lecture_template/#%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%AE%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E6%96%B9%E6%B3%95",
    
    "relUrl": "/#ローカルの環境設定方法"
  },"2": {
    "doc": "ホーム",
    "title": "手元で動かすのに必要なもの",
    "content": ". | Ruby . | rbenvでRubyのバージョン管理をするのが楽 (Pythonでいうところのpyenvみたいなもの). | rbenvは, homebrewであれば brew install rbenv でインストールできます. | rbenvを使ってRubyのバージョンを新しくしたい場合と手順を以下に記します. | rbenv install -l でインストールできるバージョンの一覧を取得して | rbenv install バージョン番号 でインストールして | rbenv global バージョン番号 でインストールしたバージョンをデフォルトに設定 | ~/.bash_profileに eval \"$(rbenv init -)\" を追記し, ターミナルで source ~/.bash_profile を実行. | ruby -v でRubyがちゃんと指定したバージョンになっているかを確認 | . | . | RubyGems . | bundle を gem install bundler でインストール | bundleのバージョンは gem install bundler でアップグレードできます. | . | . Jekyllをインストールし, ターミナルでフォルダに移動し . bundle install bundle exec jekyll serve --livereload . これによって, http://127.0.0.1:4000/ をブラウザで開くと書いたものをプレビューすることができます. ファイルを編集し保存するとブラウザ上の表示も自動的に更新されるはずです (自動更新をオフにしたい場合はオプション --livereload を消してください). PCにあれこれインストールしたくない場合はdockerコンテナを使う方法もあります (dockerはインストールする必要あり). ",
    "url": "/lecture_template/#%E6%89%8B%E5%85%83%E3%81%A7%E5%8B%95%E3%81%8B%E3%81%99%E3%81%AE%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%82%82%E3%81%AE",
    
    "relUrl": "/#手元で動かすのに必要なもの"
  },"3": {
    "doc": "ホーム",
    "title": "マークダウンファイルの場所",
    "content": ". | この文章は/index.mdに記述されており, トップページはこれを編集してください. | 講義資料は基本的に /doc/ に記述していきます. /doc/にフォルダを作成し, 各回ごとに整理することもできます. | 例えば /doc/第1回/講義1.md という構成になります. また, /doc/第1回/にindex.mdというファイルを作成しておくことによって, 各回ごとのトップページを作成することができます. | . | サイトの様々な設定は/_config.ymlを編集してください. 例えば以下の要素を変更できます. | ページタイトル | 右上の「製作者: 清水 伸高」 | 最下部の「Copyright © 2024 Nobutaka Shimizu. This site is powered by Github Pages.」 | . | baseurlの内容はリポジトリ名, urlの内容はhttps://GitHubのアカウント名.github.io にしないとGitHub Pagesに公開できません. baseurl: \"/lecture_template\" # /リポジトリ名 url: \"https://nobutakashimizu.github.io\" # https://アカウント名.github.io . | . ",
    "url": "/lecture_template/#%E3%83%9E%E3%83%BC%E3%82%AF%E3%83%80%E3%82%A6%E3%83%B3%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%A0%B4%E6%89%80",
    
    "relUrl": "/#マークダウンファイルの場所"
  },"4": {
    "doc": "ホーム",
    "title": "数式の記述",
    "content": "例えば . グラフ$G=(V,E)$を考える. というインラインに数式を含む文は . グラフ$G=(V,E)$を考える. のように表示されます. 複数行にまたがる式変形などは . $$ \\begin{align*} a &amp;= b \\\\ &amp;= c \\end{align*} $$ . と書けば . \\[\\begin{align*} a &amp;= b \\\\ &amp;= c \\end{align*}\\] と表示されます (念の為, 最初と最後の$$の前後には一行空けておくと良いです.) . ",
    "url": "/lecture_template/#%E6%95%B0%E5%BC%8F%E3%81%AE%E8%A8%98%E8%BF%B0",
    
    "relUrl": "/#数式の記述"
  },"5": {
    "doc": "ホーム",
    "title": "定理環境",
    "content": "定義などを述べるためのコールアウトは以下のように記述できます. このボックスには定義を記します. 以下のように, 数式ボックスを内部に含めることができます: . \\[\\begin{align*} A_{u,v} = \\begin{cases} 1 &amp; \\text{if $\\{u,v\\} \\in E$}, \\\\ 0 &amp; \\text{otherwise}. \\end{cases} \\end{align*}\\] また, 以下のようにタイトルを自由に付与することができます. 定義 (タイトル) . 定義の例. 他にも命題,補題,定理,系のボックスが使えます. このボックスには命題を記します. 証明 このように, 折りたためる証明も書けます. 内部でもインライン(例えば$a=b$)や独立した数式ブロックが書けます. $$ \\begin{align*} a &amp;= b \\\\ &amp;= c. \\end{align*} $$ しかし, なぜかマークダウンはかけません. この中で強調表示したい場合は, 苦肉の策ですが, htmlタグを使って装飾しましょう. $\\square$ このボックスには定理(特に重要度の高い命題)を記します. このボックスには命題や定理を示すために必要な補助的な主張を記します . このボックスには定理や命題などから直ちに成り立つ結果を記します. このボックスには強調したい注釈が入ります. ",
    "url": "/lecture_template/#%E5%AE%9A%E7%90%86%E7%92%B0%E5%A2%83",
    
    "relUrl": "/#定理環境"
  },"6": {
    "doc": "ホーム",
    "title": "新たなコールアウトの定義方法",
    "content": "他のボックス(例えば観察,未解決問題用のコールアウトなど)を自身で追加したいときは以下の二つのファイルを適切に編集してください. | /_config.yml (コールアウトの宣言) | /just-the-docs/_sass/support/_variables.scss (背景や文字の色の定義) | . ",
    "url": "/lecture_template/#%E6%96%B0%E3%81%9F%E3%81%AA%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%A2%E3%82%A6%E3%83%88%E3%81%AE%E5%AE%9A%E7%BE%A9%E6%96%B9%E6%B3%95",
    
    "relUrl": "/#新たなコールアウトの定義方法"
  },"7": {
    "doc": "ホーム",
    "title": "注意事項",
    "content": ". | 手元の実行環境に依存しますが, 少なくとも私の環境では講義資料を格納するフォルダ名に全角文字を使うとlivereload機能にエラーが生じてしまいましたので, 念の為フォルダ明は半角にした方が良いと思います (ファイル名は全角でも大丈夫だった) | 画像を挿入する際, jekyllの「コンパイル」作業によって画像ファイル自体が別の場所に移動するため相対パスで指定すると良いです. ただし, 本来よりも一つ上のパスを指定する必要があり, 少し直感に反するので注意してください (第1回の例参照). | 数式の記述において, 記法の競合を避けるためLaTeXとは少し異なる記法をする可能性があります. | 例えば中括弧$\\{\\}$は\\{ \\}ではなく\\\\{ \\\\}とする必要があります. | また, 絶対値の記号$\\lvert \\rvert$では||ではなく\\lvert \\rvertを使わなければ正しくレンダリングされない可能性があります. | . | . ",
    "url": "/lecture_template/#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85",
    
    "relUrl": "/#注意事項"
  },"8": {
    "doc": "ホーム",
    "title": "ホーム",
    "content": "講義資料用のテンプレートです. テンプレートの大元はjust-the-docsです. マークダウンで資料を記述できます. また数式はmathjaxで書けます. ",
    "url": "/lecture_template/",
    
    "relUrl": "/"
  },"9": {
    "doc": "第1回",
    "title": "第1回",
    "content": "グラフに関する基礎的な概念の定義を与える. ",
    "url": "/lecture_template/docs/1st/",
    
    "relUrl": "/docs/1st/"
  },"10": {
    "doc": "第2回",
    "title": "第2回",
    "content": "アルゴリズムの効率性を測る指標として計算量という概念が知られている. ここでは計算量の概念を導入する. ",
    "url": "/lecture_template/docs/2nd/",
    
    "relUrl": "/docs/2nd/"
  },"11": {
    "doc": "オーダー記法",
    "title": "オーダー記法",
    "content": "# 計算量のオーダー記法 関数の漸近的な振る舞いを評価する便利な方法としてオーダー記法というものがよく用いられます. 大雑把に説明すると, 関数の支配項(最も大きい部分)を抜き出し, その係数を無視したものをその関数の**オーダー**と呼びます. 例えば, $3n^2+5n+2$ の支配項は $3n^2$ であり, 係数を無視すると $n^2$ になります. よって$3n^2+5n+2$ は $n^2$ のオーダーであるといい, $3n^2+5n+2=O(n^2)$と書きます. この説明だと多項式でないものに対してオーダーが定義できないので, 以下に厳密な定義を与えます. {: .definition } > 二つの関数$f,g\\colon \\mathbb{N} \\to \\mathbb{R}_{>0}$を考える. > ある定数$c>0$が存在して, 十分大きな全ての$n\\in \\mathbb{N}$に対して$f(n) \\le c\\cdot g(n)$が成り立つとき, $f(n)=O(g(n))$と表す. ## 例. 1からnまでの和を求める関数`sum_to_n` ```python def sum_to_n(n): S=0 for i in range(n): S=S+i return S ``` [計算量の例](../計算量とは#例-1からnまでの総和を求める関数sum_to_n)で扱った関数`sum_to_n`を再掲しています. この関数の計算時間は$n+1$なので, オーダー表記をすると$O(n)$となります. ## 例2. 1からnまでの和を計算する関数`sum_to_n2` ```python def sum_to_n2(n): return n*(n+1)/2 ``` [二つ目の例](../計算量とは#例2-1からnまでの総和を求める別の関数sum_to_n)で扱った関数`sum_to_n2`を再掲しています. この関数の計算量は2なので, オーダー表記をすると$O(1)$となります. ## 例3. 1からnまでの和を計算する関数`sum_to_n3` ```python def sum_to_n3(n): S=0 for i in range(n): a = i S = S+a return S ``` 例1の関数`sum_to_n()`と本質的に同じ処理をしています. 計算時間は`a=i`という操作をしているので, $2n+1$になり, 例1よりも遅くなっていますが, オーダーは$O(n)$となります. このように, 細かく見ると違う処理をしているが本質的に同じ処理をしている関数は多くの場合, 計算時間をオーダーで評価すると同じになります. このように, **オーダー表記はアルゴリズムの(細かい処理を無視した)本質的な計算時間を評価するのに便利です**. ## 例4. 文字列が回文かどうかを判定する関数`is_palindrome` ```python def is_palindrome(s): n = len(s) for i in range(n): if s[i] != s[n-i-1]: return False return True ``` > 途中に`return`が実行されるとその時点で関数の処理は終了します. なので, 例えば上記コードの5行目のように, for文の中で条件に合致するものを見つけたときに`return`することによってその有無を判定することができます. > 関数`is_palindrome`はfor文の中で1回だけ文字列の比較を行なっているので, ステップ数は高々$n$. よって計算量は$O(n)$. ## 例5. 二つのリストの結合 ```python def list_concatenate(a,b): c=a+b return c ``` 一見すると`list_concatenate`のステップ数は1, 即ち計算量は$O(1)$に見えるのですが, 実際にはPythonのリストで`a+b`を計算しているときは`a`の後ろに`b`の要素を順番に一つずつ追加しているので, 要するステップ数は$n$. つまり計算量は$O(n)$となります. {: .remark } > オーダー記法の考え方自体はアルゴリズムの計算量に限らず, テイラー展開など関数の漸近的な振る舞いを知りたい場合によく使われる概念です. # 色んなオーダー記法 より一般に, $O(\\cdot)$の不等号の向きを逆にしたものなど, 様々なオーダーの概念があります. {: .definition } > 二つの関数$f,g\\colon \\mathbb{N} \\to \\mathbb{R}_{>0}$を考える. > - ある定数$c>0$が存在して, 十分大きな全ての$n\\in \\mathbb{N}$に対して$f(g) \\ge c\\cdot g(n)$が成り立つとき, $f(n)=\\Omega(g(n))$ と表す. > - $f(n)=O(g(n))$ かつ $g(n)=O(f(n))$ であるとき, $f(n)=\\Theta(g(n))$と表す. > - 任意の定数$c>0$に対してある$n_0\\in \\mathbb{N}$が存在して, 全ての$n\\ge n_0$に対して$f(n)\\ge c\\cdot g(n)$ 成り立つとき, $f(n)=\\omega(g(n))$ と表す.　不等号が逆, すなわち $f(n)\\le c\\cdot g(n)$ が成り立つとき, $f(n) = o(g(n))$ と表す. # Exercise 以下の問いに答えよ. 1. $f(n)=O(g(n))$ でも $g(n)=O(f(n))$ でもないような$f,g$を例示せよ. 2. 任意の$c>0$に対して$f(n)=O(n^c)$を満たすような$f$を一つ例示せよ. 3. 任意の$c>0$に対して$f(n)=\\Omega(n^c)$を満たすような$f$を一つ例示せよ. 4. $f(n)=n!$と$g(n)=2^{3n}$に対し, $f(n)=\\omega(g(n))$が成り立つことを証明せよ. ",
    "url": "/lecture_template/docs/2nd/%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC%E8%A8%98%E6%B3%95/",
    
    "relUrl": "/docs/2nd/%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC%E8%A8%98%E6%B3%95/"
  },"12": {
    "doc": "グラフの基礎的な概念",
    "title": "グラフの基礎的な概念",
    "content": "# グラフの基礎的な概念 ここではグラフに関する基本的な用語の定義を紹介します. グラフ$G=(V,E)$を考えます. # 次数 {: .definition } > 頂点$u\\in V$に対し, $u$に接続している辺の本数を**次数**と呼び, $\\deg_G(u)$で表す. グラフ$G$が文脈から明らかな場合は単に$\\deg(u)$と表す. 特に, 全て頂点の次数が$d$に等しいグラフを**$d$-正則グラフ**といいます. グラフの次数については**握手補題**と呼ばれる以下の有名な命題が成り立ちます. {: .proposition} > 任意のグラフ $G=(V,E)$に対して, 全ての頂点の次数の総和は辺の本数の二倍に等しい. すなわち > > $$ \\begin{align*} \\sum_{u\\in V}\\deg(u) = 2|E|. \\end{align*} > $$ 証明 各頂点に対して, その頂点に接続する辺の本数(すなわち次数)を考える. このとき, 各辺$e=\\left\\{ u,v \\right\\}$はそれぞれ$u$と$v$における数え上げでカウントされるため, ちょうど二回カウントされる. よって, 次数の総和は辺の本数の二倍に等しい. $\\square$ 握手補題より, $n$頂点$d$-正則グラフは$nd$が偶数の時しか存在しえないことがわかります. # 部分グラフ {: .definition} > グラフ$H=(U,F)$が$U\\subseteq V$かつ$F\\subseteq E$を満たすとき, $H$は$G$の**部分グラフ**であるという. > 特に, ある頂点部分集合$U\\subseteq V$に対して$\\left( U,\\binom{U}{2}\\cap E \\right)$で与えられる部分グラフを**誘導部分グラフ**と呼び, $G[U]$で表す. # 路と閉路 {: .definition } > 頂点の列$(u_0,\\dots,u_\\ell) \\in V^\\ell$であって, 全ての$i=0,1,\\dots,\\ell-1$に対して $\\left\\\\{ u_i,u_{i+1} \\right\\\\}\\in E$ を満たすものを**路**という. - このときの$\\ell$を**長さ**といい, $u_0$を**始点**, $u_\\ell$を**終点**と呼ぶ. - 特に, $u_0 = u_\\ell$を満たす路を**閉路**という. - 路$(u_0,\\dots,u_\\ell)$の全ての頂点が相異なるとき, この路を特に**単純路**という. - 同様に, $\\ell\\ge 3$ かつ $u_0,\\dots,u_{\\ell-1}$が全て相異なる($u_\\ell$は含まれていないことに注意)ような閉路を**単純閉路**という. - 始点が$s$, 終点が$t$であるような路を特に$st$-路と呼ぶ. 路を用いてグラフの頂点集合上に距離を以下のように定めることができます. {: .definition } > 二頂点$s,t\\in V$に対し, $st$-路の中での最小の長さを$st$間の**距離**と呼び, $\\mathrm{dist}(s,t)$で表す. - 距離に等しい長さを持つ$st$-路を**最短$st$-路**と呼ぶ. - $st$-路が存在したいときは$\\mathrm{dist}(s,t)=\\infty$で表す. - 全ての二頂点間に関して距離の最大値, すなわち$\\max_{u,v\\in V}\\mathrm{dist}(u,v)$を**直径**という. 任意の二頂点$s,t\\in V$に対し$st$-路が存在するようなグラフを連結グラフという. ",
    "url": "/lecture_template/docs/1st/%E3%82%B0%E3%83%A9%E3%83%95%E3%81%AE%E5%9F%BA%E7%A4%8E%E7%9A%84%E3%81%AA%E6%A6%82%E5%BF%B5/",
    
    "relUrl": "/docs/1st/%E3%82%B0%E3%83%A9%E3%83%95%E3%81%AE%E5%9F%BA%E7%A4%8E%E7%9A%84%E3%81%AA%E6%A6%82%E5%BF%B5/"
  },"13": {
    "doc": "グラフの定義",
    "title": "グラフの定義",
    "content": "# グラフ 有限集合 $V$ と $k\\in\\mathbb{N}$ に対し, $\\binom V k$ を $V$ の $k$ 元部分集合族, すなわち $$ \\begin{align*} \\binom V k = \\left\\{ U \\subseteq V \\colon \\left| U \\right| = k \\right\\} \\end{align*} $$ とします. {: .definition} > 有限集合$V$と$E\\subseteq \\binom V 2$の組 $G=(V,E)$ を**グラフ**という. > - 集合$V$の元を頂点, $E$の元を辺という. > - グラフ$G$の頂点集合と辺集合をそれぞれ$V(G),E(G)$で表す. ## 例1 ![グラフの例2](../images/graph1.drawio.png) {: align=\"center\"} 上の図で表されるグラフは $$ \\begin{align*} &V = \\left\\{ 1,2,3,4 \\right\\},\\\\ &E = \\left\\{ \\left\\{ 1,2 \\right\\}, \\left\\{ 2,3 \\right\\},\\left\\{ 1,3 \\right\\},\\left\\{ 3,4 \\right\\} \\right\\} \\end{align*} $$ で表されます. ## 例2 ![グラフの例2](../images/graph2.drawio.png) {: align=\"center\"} 上の図で表されるグラフは $$ \\begin{align*} &V = \\left\\{ 1,2,3,4,5,6 \\right\\},\\\\ &E = \\left\\{ \\left\\{ 1,2 \\right\\},\\left\\{ 2,3 \\right\\},\\left\\{ 1,3 \\right\\},\\left\\{ 4,5 \\right\\} \\right\\} \\end{align*} $$ です. # 有向グラフ 有向グラフとは各辺が向きを持つグラフです. 有限集合$V$と自然数$k\\in \\mathbb{N}$に対し, $V$の$k$個の要素からなる順序付きタプルの全体を$(V)_k$ とします. すなわち $$ \\begin{align*} (V)_k = \\left\\{ (v_1,\\dots,v_k) \\in V^k \\colon |\\{v_1,\\dots,v_k\\}|=k\\right\\} \\end{align*} $$ とします. {: .definition } > 非空な有限集合$V$と$\\vec E \\subseteq (V)_2$ の組$\\vec G=(V,\\vec E)$を**有向グラフ**という. > - 集合$V,E$をそれぞれ**頂点集合**, **有向辺集合**と呼び, それらの要素をそれぞれ**頂点**, **有向辺** (または孤) と呼ぶ. > - グラフ$\\vec G$の頂点集合と辺集合をそれぞれ$V(G),\\vec E(G)$で表す. グラフとの違いは単に辺の順序の有無だけです. 向きの有無を区別したい場合は有向グラフに対してグラフを特に無向グラフと呼ぶこともあります. # 重み付きグラフ 各辺に長さまたは重みと呼ばれる値が割り当てられたグラフを重みグラフと呼びます. {: .definition } > グラフ$(V,E)$と関数$w\\colon E \\to \\mathbb{R}$に対し, 三つ組$G=(V,E,w)$を**重み付きグラフ**といい, 関数$w$を**重み**と呼ぶ. 重みは正であることを仮定することが多く, 負の値をとりうる場合は基本的にはそれを明示します. 文脈によっては重みのことを長さと呼ぶこともあります(最短経路問題など). ",
    "url": "/lecture_template/docs/1st/%E3%82%B0%E3%83%A9%E3%83%95%E3%81%AE%E5%AE%9A%E7%BE%A9/",
    
    "relUrl": "/docs/1st/%E3%82%B0%E3%83%A9%E3%83%95%E3%81%AE%E5%AE%9A%E7%BE%A9/"
  },"14": {
    "doc": "計算量とは",
    "title": "計算量とは",
    "content": "# 計算量とは? **アルゴリズム**とは, 問題を解くための計算の手続きのことです. 同じ問題を解くにも様々なアルゴリズムが考えられますが, その中で最も効率的なものが望ましいです. そこでアルゴリズムの効率性を定量的に測る尺度として**計算量 (computational complexity)** が定義されます. 計算量にも様々なものがあり, 例えば時間計算量や空間計算量などがあります. - **時間計算量 (time complexity)** : サイズ$n$の任意の入力に対し, 計算が終わるまでにかかるステップ数. - **空間計算量 (space complexity)** : サイズ$n$の任意の入力に対し, 計算が終わるまでに使用したメモリのサイズ 考える問題によって入力のサイズは変わってきます. 例えば文字列を扱う問題は与えられる文字列の長さを$n$とすることが多く, 行列を扱う問題は, 例えば$n\\times n$ 行列を扱うときは入力長は $n^2$ だが入力のサイズを$n$と定義するもある. {: .remark } > 本講義では特に断りのない限り, 計算量と言えば時間計算量を指すものとし, 基本的な演算(加算や掛け算など)の回数によって測ります. ### 例: 1からnまでの総和を求める関数`sum_to_n()` ```python def sum_to_n(n): S=0 for i in range(1,n+1): S=S+i return S ``` この関数は`S=0`と`S=S+i`のそれぞれで変数`S`の値を更新しています. 計算回数は`S=0`の箇所では1回, `S=S+i`は$n$回実行されるので, この関数の計算量は$n+1$となります. ### 例2. 1からnまでの総和を求める別の関数`sum_to_n()` ```python def sum_to_n(n): return n*(n+1)//2 ``` この関数は等差数列の和の公式を使って1からnまでの和を計算する関数になっています. `n*(n+1)//2`では, まず最初に $n\\cdot (n-1)$ を計算し, その次に2で割っているので, 計算回数は2となります. 例1と同じ値を計算していますが, $n$ が大きくなった時はこちらの方が計算回数が少ないので高速です. つまり, 例2のアルゴリズムの方が効率的であるとみなします. 実際のプログラムの実行時間は同じアルゴリズムであっても実装したときのプログラミング言語や実行環境によって変動しうるので, 「アルゴリズムの効率性」を議論する場合はこれらの要因を排除して行うのが基本です. 例えば実行環境によっては同じアルゴリズムを２回走らせるということもあるかもしれません. 従って, 計算量の議論をする際は定数倍を無視するという慣習があります. 詳しくは[オーダー記法](../オーダー記法)を参照してください. ",
    "url": "/lecture_template/docs/2nd/%E8%A8%88%E7%AE%97%E9%87%8F%E3%81%A8%E3%81%AF/",
    
    "relUrl": "/docs/2nd/%E8%A8%88%E7%AE%97%E9%87%8F%E3%81%A8%E3%81%AF/"
  },"15": {
    "doc": "隣接行列と隣接リスト",
    "title": "隣接行列と隣接リスト",
    "content": "グラフを計算機上で表現する代表的な方法として隣接行列と隣接リストが知られています. # 隣接行列 {: .definition } > グラフ$G=(V,E)$の**隣接行列**とは, 行列 $A\\in \\\\{0,1\\\\}^{V\\times V}$ であり, 各$(i,j)$成分 $A(i,j)$ は > > $$ A(i,j) = \\begin{cases} 1 & \\text{if $\\{i,j\\}\\in E$},\\\\ 0 & \\text{otherwise}. \\end{cases} > $$ > > で与えられるものである. > 有向グラフの場合も同様に, $(i,j)$成分を有向辺$(i,j)$の有無で定める. 無向グラフの隣接行列は常に対称行列となりますが, 有向の場合は必ずしもそうとは限りません. プログラムで書く時は二次元リストで表現し, `A[i][j]`に$A_{i,j}$ を格納します. 本講義では特に自己ループ $u\\sim u$ となるグラフは考えないので常に $A_{i,i}=0$ となります. 例えば上図のグラフを隣接行列で表現すると以下の行列になります. $$ \\begin{align*} A = \\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 1 & 0 & 0\\\\ 0 & 1 & 0 & 1 & 0 & 0\\\\ 0 & 1 & 1 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 \\end{bmatrix} \\end{align*} $$ 頂点5はどの頂点とも隣接していないため, 頂点5に対応する行と列の成分は全て$0$になっています. # 隣接リスト 隣接リスト`N`は二次元リストであり, $i=0,1,\\dots,n-1$ に対して `N[i]`は長さ$\\deg(i)$ のリストであり, $i$ と隣接している頂点を格納されています. ここで$\\deg(i)$ は頂点 $i$ の次数です. 例えば上図のグラフを隣接リストで表現すると以下のリストになります: ```python N = [ [1], #頂点0の隣接頂点のリスト [0,2,3],#頂点1に隣接頂点のリスト [1,3], [1,2], [3], [] #頂点5に隣接している頂点は存在しない ] ``` 例えば `N[0]` は頂点$0$に隣接している頂点が格納されたリストになっています. # 重み付きグラフの表現 重み付きグラフ$G=(V,E,w)$も隣接リストを少し修正するだけで表現できます. 隣接リストを `wN` とすると各 `wN[u]` は頂点$u$に隣接している頂点とその頂点に向かう辺の重みをタプルとして保持するリストとします. 例えば上図のグラフを重み付き隣接リストで表現すると ```python wN = [ [(2,16)], #頂点0からは頂点2に向かう重さ16の辺が存在 [(2,8),(3,11)], [(0,16),(1,8),(3,7)], [(1,11),(2,7)], [(3,9)], [] ] ``` となります ",
    "url": "/lecture_template/docs/1st/%E9%9A%A3%E6%8E%A5%E8%A1%8C%E5%88%97%E3%81%A8%E9%9A%A3%E6%8E%A5%E3%83%AA%E3%82%B9%E3%83%88/",
    
    "relUrl": "/docs/1st/%E9%9A%A3%E6%8E%A5%E8%A1%8C%E5%88%97%E3%81%A8%E9%9A%A3%E6%8E%A5%E3%83%AA%E3%82%B9%E3%83%88/"
  }
}
